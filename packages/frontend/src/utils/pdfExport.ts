import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

export interface DocumentPdfOptions {
  title: string;
  docNumber: string;
  status: string;
  createdAt: string;
  fields: Array<{ label: string; value: string }>;
  lineItems?: Array<Record<string, string | number>>;
  lineItemColumns?: string[];
  /** Optional signature lines (e.g. ['Prepared By', 'Approved By', 'Received By']) */
  signatures?: string[];
  /** Whether to open print dialog instead of saving */
  printMode?: boolean;
}

export function generateDocumentPdf(options: DocumentPdfOptions) {
  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.getWidth();

  // Header - NIT branding
  doc.setFillColor(46, 49, 146); // nesma-primary
  doc.rect(0, 0, pageWidth, 40, 'F');
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(20);
  doc.text('NIT Logistics & WMS', 14, 18);
  doc.setFontSize(10);
  doc.text('Nesma Infrastructure & Technology', 14, 26);
  doc.text(options.title, 14, 34);

  // Document info
  doc.setTextColor(0, 0, 0);
  doc.setFontSize(14);
  doc.text(options.docNumber, 14, 52);

  doc.setFontSize(10);
  doc.setTextColor(100, 100, 100);
  doc.text(`Status: ${options.status}`, pageWidth - 14, 52, { align: 'right' });
  doc.text(`Date: ${options.createdAt}`, pageWidth - 14, 58, { align: 'right' });

  // Fields section (two-column layout)
  let yPos = 68;
  doc.setFontSize(10);

  for (let i = 0; i < options.fields.length; i += 2) {
    const field1 = options.fields[i];
    const field2 = options.fields[i + 1];

    doc.setTextColor(100, 100, 100);
    doc.text(field1.label + ':', 14, yPos);
    doc.setTextColor(0, 0, 0);
    doc.text(String(field1.value || '-'), 70, yPos);

    if (field2) {
      doc.setTextColor(100, 100, 100);
      doc.text(field2.label + ':', pageWidth / 2 + 5, yPos);
      doc.setTextColor(0, 0, 0);
      doc.text(String(field2.value || '-'), pageWidth / 2 + 55, yPos);
    }

    yPos += 8;
  }

  // Line items table
  if (options.lineItems && options.lineItems.length > 0 && options.lineItemColumns) {
    yPos += 10;
    doc.setFontSize(12);
    doc.setTextColor(0, 0, 0);
    doc.text('Line Items', 14, yPos);

    autoTable(doc, {
      startY: yPos + 5,
      head: [options.lineItemColumns],
      body: options.lineItems.map(item => options.lineItemColumns!.map(col => String(item[col] ?? ''))),
      theme: 'grid',
      headStyles: { fillColor: [46, 49, 146], textColor: 255 },
      styles: { fontSize: 9 },
    });
  }

  // Signature lines
  const signatures = options.signatures ?? getDefaultSignatures(options.title);
  if (signatures.length > 0) {
    // Get current Y position after autoTable or field section
    const finalY = (doc as unknown as { lastAutoTable?: { finalY: number } }).lastAutoTable?.finalY ?? yPos;
    let sigY = finalY + 20;

    // Check if we need a new page for signatures
    const pageHeight = doc.internal.pageSize.getHeight();
    if (sigY + 40 > pageHeight - 20) {
      doc.addPage();
      sigY = 30;
    }

    const sigColWidth = (pageWidth - 28) / Math.min(signatures.length, 3);
    doc.setFontSize(9);

    signatures.forEach((label, i) => {
      const x = 14 + (i % 3) * sigColWidth;
      const rowY = sigY + Math.floor(i / 3) * 40;

      // Signature line
      doc.setDrawColor(180, 180, 180);
      doc.line(x, rowY + 20, x + sigColWidth - 10, rowY + 20);

      // Label
      doc.setTextColor(100, 100, 100);
      doc.text(label, x, rowY + 26);

      // Date line
      doc.setTextColor(180, 180, 180);
      doc.text('Date: _______________', x, rowY + 32);
    });
  }

  // Footer
  const footerY = doc.internal.pageSize.getHeight() - 15;
  doc.setFontSize(8);
  doc.setTextColor(150, 150, 150);
  doc.text('Generated by NIT Logistics & WMS', 14, footerY);
  doc.text(new Date().toLocaleString(), pageWidth - 14, footerY, { align: 'right' });

  // Print or Download
  if (options.printMode) {
    doc.autoPrint();
    window.open(doc.output('bloburl'), '_blank');
  } else {
    doc.save(`${options.docNumber}.pdf`);
  }
}

/** Default signature labels per document type */
function getDefaultSignatures(title: string): string[] {
  const lower = title.toLowerCase();
  if (lower.includes('receiving')) return ['Received By', 'Checked By (QC)', 'Warehouse Supervisor'];
  if (lower.includes('issue')) return ['Requested By', 'Approved By', 'Issued By'];
  if (lower.includes('return')) return ['Returned By', 'Received By', 'Warehouse Supervisor'];
  if (lower.includes('inspection')) return ['Inspector', 'QC Manager'];
  if (lower.includes('gate pass')) return ['Issued By', 'Security Officer'];
  if (lower.includes('job order')) return ['Requested By', 'Approved By', 'Contractor'];
  if (lower.includes('stock transfer')) return ['Requested By', 'Approved By', 'Shipped By', 'Received By'];
  return ['Prepared By', 'Approved By'];
}

// ---------------------------------------------------------------------------
// NIT letterhead-style PDF generators (consolidated from lib/pdfExport.ts)
// ---------------------------------------------------------------------------

// NIT brand colors
const PRIMARY_BLUE = '#1e3a5f';
const SECONDARY_GOLD = '#c5a572';
const LIGHT_GRAY = '#f5f5f5';

export interface PdfOptions {
  title: string;
  subtitle?: string;
  date?: Date;
  documentNumber?: string;
  orientation?: 'portrait' | 'landscape';
}

export interface TableColumn {
  header: string;
  dataKey: string;
  width?: number;
}

/**
 * Create a new jsPDF instance with NIT letterhead.
 * Top: "NIT Supply Chain Management" (blue, 16pt), document title below (14pt)
 * Right-aligned: Date, Document Number
 * Footer added via didDrawPage hook: Page X of Y, "Generated by NIT SCS V2"
 */
export function createNitPdf(options: PdfOptions): jsPDF {
  const { title, subtitle, date = new Date(), documentNumber, orientation = 'portrait' } = options;

  const doc = new jsPDF({ orientation, unit: 'mm', format: 'a4' });
  const pageWidth = doc.internal.pageSize.getWidth();

  // --- Header ---
  // Company name
  doc.setFontSize(16);
  doc.setTextColor(PRIMARY_BLUE);
  doc.setFont('helvetica', 'bold');
  doc.text('NIT Supply Chain Management', 14, 18);

  // Document title
  doc.setFontSize(14);
  doc.setTextColor(SECONDARY_GOLD);
  doc.text(title, 14, 26);

  // Subtitle
  if (subtitle) {
    doc.setFontSize(10);
    doc.setTextColor('#666666');
    doc.setFont('helvetica', 'normal');
    doc.text(subtitle, 14, 32);
  }

  // Right-aligned: date + document number
  doc.setFontSize(9);
  doc.setTextColor('#444444');
  doc.setFont('helvetica', 'normal');
  const dateStr = date.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
  doc.text(`Date: ${dateStr}`, pageWidth - 14, 18, { align: 'right' });
  if (documentNumber) {
    doc.text(`Doc #: ${documentNumber}`, pageWidth - 14, 24, { align: 'right' });
  }

  // Separator line
  const lineY = subtitle ? 36 : 30;
  doc.setDrawColor(PRIMARY_BLUE);
  doc.setLineWidth(0.5);
  doc.line(14, lineY, pageWidth - 14, lineY);

  // Footer hook: runs on every page
  const totalPagesPlaceholder = '{total_pages_count_string}';
  doc.setFont('helvetica', 'normal');

  // We use the internal event system via autoTable's didDrawPage
  // but also set up a final page count replacement
  const pageCount = doc.getNumberOfPages;
  // Store reference for the finalize step
  (doc as unknown as Record<string, unknown>).__nitStartY = lineY + 6;
  (doc as unknown as Record<string, unknown>).__nitTotalPlaceholder = totalPagesPlaceholder;

  return doc;
}

/**
 * Get the current Y position to start content after the header.
 */
export function getStartY(doc: jsPDF): number {
  return ((doc as unknown as Record<string, unknown>).__nitStartY as number) ?? 40;
}

/**
 * Add a data table to the PDF using jspdf-autotable.
 * Returns the final Y position after the table.
 */
export function addTable(doc: jsPDF, columns: TableColumn[], data: Record<string, unknown>[], startY?: number): number {
  const y = startY ?? getStartY(doc);

  autoTable(doc, {
    startY: y,
    head: [columns.map(c => c.header)],
    body: data.map(row => columns.map(c => String(row[c.dataKey] ?? ''))),
    headStyles: {
      fillColor: PRIMARY_BLUE,
      textColor: '#ffffff',
      fontStyle: 'bold',
      fontSize: 8,
      halign: 'left',
    },
    bodyStyles: {
      fontSize: 8,
      textColor: '#333333',
      cellPadding: 2,
    },
    alternateRowStyles: {
      fillColor: LIGHT_GRAY,
    },
    columnStyles: columns.reduce(
      (acc, col, idx) => {
        if (col.width) {
          acc[idx] = { cellWidth: col.width };
        }
        return acc;
      },
      {} as Record<number, { cellWidth: number }>,
    ),
    margin: { left: 14, right: 14 },
    didDrawPage: hookData => {
      addNitPageFooter(doc);
    },
  });

  const lastTable = (doc as unknown as Record<string, unknown>).lastAutoTable as { finalY: number } | undefined;
  return lastTable?.finalY ?? y + 10;
}

/**
 * Add a key-value info section (like document header fields).
 * Returns the Y position after the section.
 */
export function addInfoSection(doc: jsPDF, fields: Array<{ label: string; value: string }>, startY: number): number {
  let y = startY;
  const leftCol = 14;
  const valueCol = 60;
  const lineHeight = 6;

  for (const field of fields) {
    doc.setFontSize(9);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(PRIMARY_BLUE);
    doc.text(`${field.label}:`, leftCol, y);

    doc.setFont('helvetica', 'normal');
    doc.setTextColor('#333333');
    doc.text(field.value, valueCol, y);

    y += lineHeight;
  }

  return y + 2;
}

/**
 * Add page footer with page numbers and generation note.
 */
function addNitPageFooter(doc: jsPDF): void {
  const pageHeight = doc.internal.pageSize.getHeight();
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageNumber = doc.getCurrentPageInfo().pageNumber;

  doc.setFontSize(7);
  doc.setTextColor('#999999');
  doc.setFont('helvetica', 'normal');

  // Left: generation note
  doc.text('Generated by NIT SCS V2', 14, pageHeight - 8);

  // Right: page number
  doc.text(`Page ${pageNumber}`, pageWidth - 14, pageHeight - 8, { align: 'right' });

  // Subtle line above footer
  doc.setDrawColor('#cccccc');
  doc.setLineWidth(0.2);
  doc.line(14, pageHeight - 12, pageWidth - 14, pageHeight - 12);
}

/**
 * Trigger browser download of the PDF.
 */
export function downloadPdf(doc: jsPDF, filename: string): void {
  // Add footers to all pages before saving
  const totalPages = doc.getNumberOfPages();
  for (let i = 1; i <= totalPages; i++) {
    doc.setPage(i);
    addNitPageFooter(doc);
  }
  doc.save(filename.endsWith('.pdf') ? filename : `${filename}.pdf`);
}

// ---------------------------------------------------------------------------
// Document-specific PDF generators
// ---------------------------------------------------------------------------

export interface GrnLineItem {
  itemCode: string;
  itemName: string;
  unit: string;
  quantity: number;
  unitPrice: number;
  totalPrice: number;
  condition?: string;
}

export interface GrnData {
  documentNumber: string;
  supplier: string;
  warehouse: string;
  receivedDate: string;
  poNumber?: string;
  status: string;
  items: GrnLineItem[];
  notes?: string;
}

export function generateGrnPdf(grn: GrnData): void {
  const doc = createNitPdf({
    title: 'Goods Receipt Note (GRN)',
    documentNumber: grn.documentNumber,
    subtitle: `Supplier: ${grn.supplier}`,
  });

  let y = addInfoSection(
    doc,
    [
      { label: 'Document #', value: grn.documentNumber },
      { label: 'Supplier', value: grn.supplier },
      { label: 'Warehouse', value: grn.warehouse },
      { label: 'Received Date', value: grn.receivedDate },
      { label: 'PO Number', value: grn.poNumber ?? 'N/A' },
      { label: 'Status', value: grn.status },
    ],
    getStartY(doc),
  );

  y = addTable(
    doc,
    [
      { header: '#', dataKey: '_index', width: 10 },
      { header: 'Code', dataKey: 'itemCode', width: 30 },
      { header: 'Description', dataKey: 'itemName' },
      { header: 'Unit', dataKey: 'unit', width: 15 },
      { header: 'Qty', dataKey: 'quantity', width: 15 },
      { header: 'Price', dataKey: 'unitPrice', width: 20 },
      { header: 'Total', dataKey: 'totalPrice', width: 25 },
      { header: 'Condition', dataKey: 'condition', width: 20 },
    ],
    grn.items.map((item, i) => ({
      ...item,
      _index: String(i + 1),
      unitPrice: item.unitPrice.toLocaleString(),
      totalPrice: item.totalPrice.toLocaleString(),
      condition: item.condition ?? 'New',
    })),
    y + 4,
  );

  // Grand total
  const grandTotal = grn.items.reduce((s, i) => s + i.totalPrice, 0);
  doc.setFontSize(10);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(PRIMARY_BLUE);
  doc.text(`Grand Total: ${grandTotal.toLocaleString()} SAR`, doc.internal.pageSize.getWidth() - 14, y + 8, {
    align: 'right',
  });

  if (grn.notes) {
    doc.setFontSize(8);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor('#666666');
    doc.text(`Notes: ${grn.notes}`, 14, y + 16);
  }

  downloadPdf(doc, `GRN_${grn.documentNumber}_${new Date().toISOString().slice(0, 10)}`);
}

export interface MiData {
  documentNumber: string;
  project: string;
  requester: string;
  issuedDate: string;
  warehouse: string;
  status: string;
  items: GrnLineItem[];
  notes?: string;
}

export function generateMiPdf(mi: MiData): void {
  const doc = createNitPdf({
    title: 'Material Issuance (MI)',
    documentNumber: mi.documentNumber,
    subtitle: `Project: ${mi.project}`,
  });

  let y = addInfoSection(
    doc,
    [
      { label: 'Document #', value: mi.documentNumber },
      { label: 'Project', value: mi.project },
      { label: 'Requester', value: mi.requester },
      { label: 'Issued Date', value: mi.issuedDate },
      { label: 'Warehouse', value: mi.warehouse },
      { label: 'Status', value: mi.status },
    ],
    getStartY(doc),
  );

  y = addTable(
    doc,
    [
      { header: '#', dataKey: '_index', width: 10 },
      { header: 'Code', dataKey: 'itemCode', width: 30 },
      { header: 'Description', dataKey: 'itemName' },
      { header: 'Unit', dataKey: 'unit', width: 15 },
      { header: 'Qty', dataKey: 'quantity', width: 15 },
      { header: 'Price', dataKey: 'unitPrice', width: 20 },
      { header: 'Total', dataKey: 'totalPrice', width: 25 },
    ],
    mi.items.map((item, i) => ({
      ...item,
      _index: String(i + 1),
      unitPrice: item.unitPrice.toLocaleString(),
      totalPrice: item.totalPrice.toLocaleString(),
    })),
    y + 4,
  );

  const grandTotal = mi.items.reduce((s, i) => s + i.totalPrice, 0);
  doc.setFontSize(10);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(PRIMARY_BLUE);
  doc.text(`Grand Total: ${grandTotal.toLocaleString()} SAR`, doc.internal.pageSize.getWidth() - 14, y + 8, {
    align: 'right',
  });

  downloadPdf(doc, `MI_${mi.documentNumber}_${new Date().toISOString().slice(0, 10)}`);
}

export interface GatePassData {
  documentNumber: string;
  type: string;
  date: string;
  warehouse: string;
  vehiclePlate: string;
  driverName: string;
  driverIdNumber?: string;
  linkedDocument?: string;
  status: string;
  notes?: string;
}

export function generateGatePassPdf(gatePass: GatePassData): void {
  const doc = createNitPdf({
    title: 'Gate Pass',
    documentNumber: gatePass.documentNumber,
    subtitle: `Type: ${gatePass.type}`,
  });

  let y = addInfoSection(
    doc,
    [
      { label: 'Document #', value: gatePass.documentNumber },
      { label: 'Type', value: gatePass.type },
      { label: 'Date', value: gatePass.date },
      { label: 'Warehouse', value: gatePass.warehouse },
      { label: 'Vehicle Plate', value: gatePass.vehiclePlate },
      { label: 'Driver Name', value: gatePass.driverName },
      { label: 'Driver ID', value: gatePass.driverIdNumber ?? 'N/A' },
      { label: 'Linked Document', value: gatePass.linkedDocument ?? 'None' },
      { label: 'Status', value: gatePass.status },
    ],
    getStartY(doc),
  );

  if (gatePass.notes) {
    doc.setFontSize(9);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor('#666666');
    doc.text(`Notes: ${gatePass.notes}`, 14, y + 4);
    y += 10;
  }

  // Signature line
  y += 16;
  doc.setDrawColor('#333333');
  doc.setLineWidth(0.3);
  doc.line(14, y, 80, y);
  doc.line(110, y, 196, y);

  doc.setFontSize(8);
  doc.setTextColor('#666666');
  doc.text('Security Guard Signature', 14, y + 5);
  doc.text('Authorized By', 110, y + 5);

  downloadPdf(doc, `GatePass_${gatePass.documentNumber}_${new Date().toISOString().slice(0, 10)}`);
}

export interface JobOrderData {
  documentNumber: string;
  project: string;
  requester: string;
  requestDate: string;
  joType: string;
  priority: string;
  driverName?: string;
  vehiclePlate?: string;
  status: string;
  notes?: string;
}

export function generateJobOrderPdf(jobOrder: JobOrderData): void {
  const doc = createNitPdf({
    title: 'Job Order',
    documentNumber: jobOrder.documentNumber,
    subtitle: `Type: ${jobOrder.joType} | Priority: ${jobOrder.priority}`,
  });

  const y = addInfoSection(
    doc,
    [
      { label: 'Document #', value: jobOrder.documentNumber },
      { label: 'Project', value: jobOrder.project },
      { label: 'Requester', value: jobOrder.requester },
      { label: 'Request Date', value: jobOrder.requestDate },
      { label: 'Type', value: jobOrder.joType },
      { label: 'Priority', value: jobOrder.priority },
      { label: 'Driver', value: jobOrder.driverName ?? 'N/A' },
      { label: 'Vehicle Plate', value: jobOrder.vehiclePlate ?? 'N/A' },
      { label: 'Status', value: jobOrder.status },
    ],
    getStartY(doc),
  );

  if (jobOrder.notes) {
    doc.setFontSize(9);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor('#666666');
    doc.text(`Notes: ${jobOrder.notes}`, 14, y + 4);
  }

  downloadPdf(doc, `JO_${jobOrder.documentNumber}_${new Date().toISOString().slice(0, 10)}`);
}

export interface InventoryItem {
  sn: number;
  project: string;
  itemCode: string;
  description: string;
  size: string;
  unit: string;
  location: string;
  subLocation: string;
  balance: number;
}

export function generateInventoryReportPdf(items: InventoryItem[], warehouseName: string): void {
  const doc = createNitPdf({
    title: 'Inventory Report',
    subtitle: `Warehouse: ${warehouseName}`,
    orientation: items.length > 0 ? 'landscape' : 'portrait',
  });

  const totalBalance = items.reduce((s, i) => s + i.balance, 0);

  const y = addInfoSection(
    doc,
    [
      { label: 'Warehouse', value: warehouseName },
      { label: 'Total Items', value: String(items.length) },
      { label: 'Total Balance', value: totalBalance.toLocaleString() },
      {
        label: 'Report Date',
        value: new Date().toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' }),
      },
    ],
    getStartY(doc),
  );

  addTable(
    doc,
    [
      { header: '#', dataKey: 'sn', width: 10 },
      { header: 'Project', dataKey: 'project', width: 35 },
      { header: 'Code', dataKey: 'itemCode', width: 40 },
      { header: 'Description', dataKey: 'description' },
      { header: 'Size', dataKey: 'size', width: 25 },
      { header: 'Unit', dataKey: 'unit', width: 12 },
      { header: 'Location', dataKey: 'locationFull', width: 30 },
      { header: 'Balance', dataKey: 'balance', width: 20 },
    ],
    items.map(item => ({
      ...item,
      locationFull: `${item.location} - ${item.subLocation}`,
      balance: item.balance.toLocaleString(),
    })),
    y + 4,
  );

  downloadPdf(doc, `Inventory_${warehouseName.replace(/\s+/g, '_')}_${new Date().toISOString().slice(0, 10)}`);
}

// ---------------------------------------------------------------------------
// Generic document & report PDF generators
// ---------------------------------------------------------------------------

export interface ReportPdfOptions {
  title: string;
  subtitle?: string;
  generatedAt?: string;
  filters?: Array<{ label: string; value: string }>;
  columns: string[];
  rows: Array<Record<string, string | number>>;
  summary?: Array<{ label: string; value: string | number }>;
}

export function generateReportPdf(options: ReportPdfOptions) {
  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.getWidth();

  // Header - NIT branding
  doc.setFillColor(46, 49, 146);
  doc.rect(0, 0, pageWidth, 40, 'F');
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(20);
  doc.text('NIT Logistics & WMS', 14, 18);
  doc.setFontSize(10);
  doc.text('Nesma Infrastructure & Technology', 14, 26);
  doc.setFontSize(14);
  doc.text(options.title, 14, 36);

  let yPos = 50;

  // Subtitle + date
  doc.setTextColor(100, 100, 100);
  doc.setFontSize(10);
  if (options.subtitle) {
    doc.text(options.subtitle, 14, yPos);
    yPos += 6;
  }
  doc.text(`Generated: ${options.generatedAt || new Date().toLocaleString()}`, 14, yPos);
  yPos += 10;

  // Filters
  if (options.filters && options.filters.length > 0) {
    doc.setFontSize(9);
    doc.setTextColor(80, 80, 80);
    options.filters.forEach(f => {
      doc.text(`${f.label}: ${f.value}`, 14, yPos);
      yPos += 5;
    });
    yPos += 5;
  }

  // Summary cards
  if (options.summary && options.summary.length > 0) {
    doc.setFontSize(11);
    doc.setTextColor(0, 0, 0);
    const colW = (pageWidth - 28) / Math.min(options.summary.length, 4);
    options.summary.forEach((s, i) => {
      const x = 14 + (i % 4) * colW;
      doc.setFontSize(8);
      doc.setTextColor(100, 100, 100);
      doc.text(s.label, x, yPos);
      doc.setFontSize(14);
      doc.setTextColor(0, 0, 0);
      doc.text(String(s.value), x, yPos + 6);
    });
    yPos += 16;
  }

  // Data table
  autoTable(doc, {
    startY: yPos,
    head: [options.columns],
    body: options.rows.map(row => options.columns.map(col => String(row[col] ?? ''))),
    theme: 'grid',
    headStyles: { fillColor: [46, 49, 146], textColor: 255 },
    styles: { fontSize: 8 },
  });

  // Footer
  const footerY = doc.internal.pageSize.getHeight() - 15;
  doc.setFontSize(8);
  doc.setTextColor(150, 150, 150);
  doc.text('Generated by NIT Logistics & WMS', 14, footerY);
  doc.text(new Date().toLocaleString(), pageWidth - 14, footerY, { align: 'right' });

  doc.save(`${options.title.replace(/\s+/g, '_')}_Report.pdf`);
}

/** Map a resource record to PDF options based on resource type */
export function buildPdfOptions(resourceType: string, record: Record<string, unknown>): DocumentPdfOptions {
  const docNumber = String(
    record.mrrvNumber ||
      record.mirvNumber ||
      record.mrvNumber ||
      record.joNumber ||
      record.rfimNumber ||
      record.osdNumber ||
      record.gatePassNumber ||
      record.transferNumber ||
      record.shipmentNumber ||
      record.id ||
      '',
  );
  const common = {
    docNumber,
    status: String(record.status || ''),
    createdAt: record.createdAt
      ? new Date(String(record.createdAt)).toLocaleDateString()
      : record.date
        ? String(record.date)
        : '',
  };

  switch (resourceType) {
    case 'mrrv':
      return {
        ...common,
        title: 'Goods Receipt Note',
        fields: [
          { label: 'Supplier', value: String((record as Record<string, unknown>).supplier || record.supplierId || '') },
          {
            label: 'Warehouse',
            value: String((record as Record<string, unknown>).warehouse || record.warehouseId || ''),
          },
          { label: 'Project', value: String((record as Record<string, unknown>).project || record.projectId || '') },
          { label: 'PO Reference', value: String(record.poReference || record.poNumber || '') },
          { label: 'Delivery Note', value: String(record.deliveryNoteNumber || '') },
          { label: 'Total Value', value: record.value ? `${Number(record.value).toLocaleString()} SAR` : '-' },
          { label: 'Notes', value: String(record.notes || '') },
        ],
      };
    case 'mirv':
      return {
        ...common,
        title: 'Material Issuance',
        fields: [
          { label: 'Project', value: String(record.project || record.projectId || '') },
          { label: 'Requester', value: String(record.requester || record.requesterId || '') },
          { label: 'Warehouse', value: String(record.warehouse || record.warehouseId || '') },
          { label: 'Total Value', value: record.value ? `${Number(record.value).toLocaleString()} SAR` : '-' },
          { label: 'Notes', value: String(record.notes || '') },
        ],
      };
    case 'mrv':
      return {
        ...common,
        title: 'Material Return Note',
        fields: [
          { label: 'Return Type', value: String(record.returnType || '') },
          { label: 'Project', value: String(record.project || record.projectId || '') },
          { label: 'Warehouse', value: String(record.warehouse || record.warehouseId || '') },
          { label: 'Notes', value: String(record.notes || '') },
        ],
      };
    case 'job-orders':
      return {
        ...common,
        title: 'Job Order',
        fields: [
          { label: 'Type', value: String(record.type || '') },
          { label: 'Project', value: String(record.project || record.projectId || '') },
          { label: 'Requester', value: String(record.requester || record.requesterId || '') },
          { label: 'Vehicle', value: String(record.vehicle || '') },
          { label: 'Driver', value: String(record.driver || '') },
          { label: 'SLA Status', value: String(record.slaStatus || '') },
          { label: 'Notes', value: String(record.notes || '') },
        ],
      };
    case 'rfim':
      return {
        ...common,
        title: 'Quality Control Inspection',
        fields: [
          { label: 'GRN ID', value: String(record.mrrvId || '') },
          { label: 'Inspection Type', value: String(record.inspectionType || '') },
          { label: 'Priority', value: String(record.priority || '') },
          { label: 'Inspector', value: String(record.inspector || '') },
          { label: 'Result', value: String(record.result || record.status || '') },
          { label: 'Notes', value: String(record.notes || '') },
        ],
      };
    case 'osd':
      return {
        ...common,
        title: 'Discrepancy Report',
        fields: [
          { label: 'GRN ID', value: String(record.mrrvId || '') },
          { label: 'Report Type', value: String(record.reportType || '') },
          { label: 'Qty Affected', value: String(record.qtyAffected || '') },
          { label: 'Action Required', value: String(record.actionRequired || '') },
          { label: 'Notes', value: String(record.notes || '') },
        ],
      };
    case 'gate-pass':
      return {
        ...common,
        title: 'Gate Pass',
        fields: [
          { label: 'Type', value: String(record.type || '') },
          { label: 'Linked Document', value: String(record.linkedDocument || '') },
          { label: 'Warehouse', value: String(record.warehouse || '') },
          { label: 'Vehicle Plate', value: String(record.vehiclePlate || '') },
        ],
      };
    case 'stock-transfer':
      return {
        ...common,
        title: 'Stock Transfer',
        fields: [
          { label: 'From Warehouse', value: String(record.fromWarehouse || '') },
          { label: 'To Warehouse', value: String(record.toWarehouse || '') },
          { label: 'Notes', value: String(record.notes || '') },
        ],
      };
    case 'shipments':
      return {
        ...common,
        title: 'Shipment',
        fields: [
          { label: 'Supplier', value: String(record.supplier || '') },
          { label: 'Description', value: String(record.description || '') },
          { label: 'ETD', value: String(record.etd || '') },
          { label: 'ETA', value: String(record.eta || '') },
          { label: 'Port', value: String(record.port || '') },
          { label: 'Agent', value: String(record.agent || '') },
        ],
      };
    default:
      return {
        ...common,
        title: resourceType.toUpperCase(),
        fields: Object.entries(record)
          .filter(([k]) => !['id', 'createdAt', 'updatedAt'].includes(k))
          .slice(0, 10)
          .map(([k, v]) => ({ label: k, value: String(v ?? '') })),
      };
  }
}
